# Калибровка IMU (MPU6050)

## Назначение
Прошивка для калибровки акселерометра и гироскопа, а также для определения переда робота.

## Подготовка

1. **Поставьте робота на ровную горизонтальную поверхность**
2. **Убедитесь, что робот неподвижен**
3. Подключите ESP32 к компьютеру

## Загрузка прошивки

```powershell
cd D:\PROGECTS\stackforce\firmware\imu_calibration
platformio run --target upload
platformio device monitor -b 115200
```

## Процесс калибровки

### 1. Автоматическая калибровка при старте

При загрузке прошивки автоматически запускается калибровка гироскопа:
- Робот должен быть **неподвижен** в течение ~3 секунд
- Вы увидите точки `..........` во время сбора данных
- После калибровки отобразятся офсеты гироскопа:
  ```
  Офсеты гироскопа:
    X: 0.123
    Y: -0.456
    Z: 0.789
  ```

### 2. Проверка текущих значений

Наберите команду `s` и нажмите Enter:
```
s
```

Вы увидите:
- Акселерометр (X, Y, Z в единицах g)
- Гироскоп (X, Y, Z в °/с)
- **Углы:**
  - **Pitch** - наклон вперёд/назад (должен быть ~0° на ровной поверхности)
  - **Roll** - наклон влево/вправо (должен быть ~0° на ровной поверхности)
  - **Yaw** - поворот вокруг вертикальной оси
- Температуру датчика

### 3. Повторная калибровка (если нужно)

Если вы переместили робота или значения drift-ят, наберите:
```
c
```

⚠️ **Важно:** Робот должен быть абсолютно неподвижен!

### 4. Установка переда робота

Эта функция определяет, где у робота "перед" для корректного управления поворотом:

1. **Разверните робота в направлении, которое хотите сделать "передом"**
2. Наберите команду:
   ```
   f
   ```
3. Система зафиксирует текущий Yaw как нулевое направление

Теперь при повороте робота:
- Yaw = 0° → робот смотрит вперёд
- Yaw = 90° → робот повернул налево
- Yaw = -90° → робот повернул направо

## Команды Serial

| Команда | Описание |
|---------|----------|
| `c` | Калибровка гироскопа (робот неподвижен) |
| `s` | Показать текущие значения IMU |
| `f` | Установить текущее направление как ПЕРЕД |
| `h` | Показать помощь |

## Применение офсетов в main_controller

После калибровки вы получите офсеты гироскопа (например: `0.123, -0.456, 0.789`).

### Вариант 1: Использовать setGyroOffsets()

В файле `firmware/main_controller/src/main.cpp` в функции `setup()` после `mpu6050.init()` добавьте:

```cpp
// Инициализация IMU
mpu6050.init();
// Применить заранее откалиброванные офсеты
mpu6050.setGyroOffsets(0.123, -0.456, 0.789);  // <-- ВАШИ ЗНАЧЕНИЯ
Serial.println("[MAIN] IMU (MPU6050) инициализирован");
```

Это **пропустит** автоматическую калибровку при старте и сразу применит известные офсеты.

### Вариант 2: Комментировать calGyroOffsets()

В файле `firmware/main_controller/lib/SF_IMU/SF_IMU.cpp` в функции `init()` закомментируйте:

```cpp
void SF_IMU::init(){
    // ... другие настройки ...
    // calGyroOffsets();  // <-- Закомментировать
    update();
    // ...
}
```

Затем добавьте вызов `setGyroOffsets()` в main.cpp как в Варианте 1.

## Ориентация датчика

Если после калибровки углы "неправильные" (например, наклон вперёд даёт положительный Roll вместо Pitch), проверьте маппинг осей в `main.cpp`:

```cpp
void getMPUValue() {
    mpu6050.update();
    // Маппинг осей в зависимости от установки датчика
    robotPose.pitch = -mpu6050.angle[0];  // Инвертировать?
    robotPose.roll = mpu6050.angle[1];
    robotPose.yaw = mpu6050.angle[2];
    // ...
}
```

## Проблемы и решения

### Углы дрейфуют со временем
- Повторите калибровку командой `c`
- Убедитесь, что робот был абсолютно неподвижен во время калибровки
- Проверьте, что датчик не нагревается (температура должна быть стабильной)

### Pitch/Roll показывают ненулевые значения на ровной поверхности
- Это может быть небольшое смещение акселерометра (~1-2° нормально)
- Если больше 5°, проверьте, действительно ли поверхность горизонтальна
- Или добавьте софтверные офсеты в коде

### Yaw накапливает ошибку
- Это нормально для гироскопа без магнитометра
- Используйте команду `f` для периодического сброса
- Для точной навигации нужен магнитометр (компас) или внешние датчики

## Технические детали

- **Датчик:** MPU6050 (акселерометр + гироскоп)
- **Адрес I2C:** 0x68
- **Пины I2C:** SDA=GPIO1, SCL=GPIO2
- **Частота I2C:** 400 kHz
- **Диапазон гироскопа:** ±500°/s
- **Диапазон акселерометра:** ±2g
- **Частота дискретизации:** 8 kHz (без делителя)
- **Алгоритм фильтрации:** Комплементарный фильтр (97% гироскоп, 3% акселерометр)
